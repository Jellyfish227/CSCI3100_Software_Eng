\documentclass[11pt,a4paper]{article}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{CSCI3100 Software Engineering}
\lhead{Detailed Notes and Explanations}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}

\title{CSCI3100 Software Engineering\\
\large Complete Line-by-Line Annotated Course Notes}
\author{Compiled by OpenAI's GPT-4}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 1: Introduction (\texttt{ch1.pdf})}

\subsection*{Hello World Example and Its Implications}
\begin{tcolorbox}[title=Code Example: Using matplotlib to say Hello World]
\begin{verbatim}
# Import the matplotlib library (this is a bad comment)
import matplotlib.pyplot as p
# "Spagetti" code below...
p.rcParams["font.size"] = 20
s = p.figure().add_subplot(xticks=[], yticks=[])
t = s.text(.1, .5, "CSCI3100", color="red")
t = s.annotate(": ", xycoords=t, xy=(1, 0), verticalalignment="bottom", color="gold", weight="bold")
t = s.annotate(" hello", xycoords=t, xy=(1, 0), verticalalignment="bottom",color="green", style="italic")
t = s.annotate(" world!", xycoords=t, xy=(1, 0), verticalalignment="bottom",color="blue", family="serif")
p.show()
\end{verbatim}
\end{tcolorbox}

\textbf{Explanation:}
\begin{itemize}
    \item \texttt{import matplotlib.pyplot as p}: Imports a plotting library as `p`. The comment says this is a bad comment: it doesn't add value. This hints at the importance of meaningful documentation.
    \item The code sets font size, creates a figure, adds a subplot without ticks, and then adds a series of text and annotations to the plot, each in a different color and style.
    \item \texttt{p.show()}: Displays the figure.
    \item \textbf{Lesson:} This is a needlessly complex way of doing a simple ``Hello World''; it humorously warns students against overcomplicating code and stresses the value of simplicity and clarity in software engineering.
\end{itemize}

\subsection*{Course Content and Administration}
\begin{itemize}
    \item Lists staff members, including the lecturer (Dr. Tak-Kei Lam), his office, and email, as well as the tutors and their contact info.
    \item Explains that lectures and tutorials are in English and will mix theory and practical content.
    \item \textbf{Goals are divided into three parts:}
        \begin{itemize}
            \item \textbf{Let’s Learn:} Understand how software teams work, processes, methodologies, and compare their pros and cons; understand tools.
            \item \textbf{Be a better programmer:} Apply SE practices, propose methodologies, and go beyond just programming to full software engineering.
            \item \textbf{Be a better guy/gal:} Understand that SE is both technical and human; consider ethics, user focus, and humility in teamwork.
        \end{itemize}
    \item Meeting schedules are detailed, showing the structure and frequency of lectures and tutorials.
    \item \textbf{Course Materials:} Homepage provided for notes and assignments; textbooks are recommended but not required.
    \item \textbf{Programming Languages:} Python is the main language (for ease), with Go and Rust discussed for comparison.
    \item \textbf{Operating System:} Linux is recommended for development, though Windows and Mac are possible.
    \item \textbf{Text Editor:} Any editor is allowed but IDEs are recommended for productivity.
    \item \textbf{Late Policy:} Each student has three free late days for assignments, with a 20\% deduction per day after that.
    \item \textbf{Assessment:} 30\% assignments, 30\% group project, 40\% final (open book/notes).
    \item \textbf{Course Content:} Covers the entire SE process, specification, modeling, OO design, testing, toolchains, and best practices.
    \item \textbf{Acknowledgments:} Credits previous lecturers and sources of material.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 2: Software Development (\texttt{ch2.pdf})}

\subsection*{Why Learn About Software Engineering?}
\begin{itemize}
    \item ``Software is eating the world'': This phrase means software is now a core part of almost all industries and daily life.
    \item ``AI saving the world'': SE enables AI solutions for global issues (climate, medicine, space).
    \item ``Help you get a job (unless AI replaces programmers)'': A tongue-in-cheek reminder of automation's impact on jobs.
\end{itemize}

\subsection*{What is Software?}
\begin{itemize}
    \item Software is described as a set of objects: programs, documents, data, user guides.
    \item Software is engineered (not natural), does not ``die'' but degrades, and is inherently complex.
\end{itemize}

\subsection*{Types of Software and Their Roles}
\begin{itemize}
    \item \textbf{Product:} Delivers computing power, manages or displays data.
    \item \textbf{Vehicle:} Provides system functionality, controls other programs (like OS), facilitates communications, or helps build more software (like IDEs).
    \item \textbf{Categories:} System, engineering/scientific, web, AI, ubiquitous computing, net sourcing (web as a computing engine), open source, and more.
\end{itemize}

\subsection*{Difficulties in Writing Software}
\begin{itemize}
    \item Software is intangible---unlike civil engineering, we can’t see cracks.
    \item Hard to know if it’s correct, especially at scale; if both code and tests are wrong, errors may go unnoticed.
    \item Human brain bandwidth is limited (``10 bits/sec'' is a humorous exaggeration).
    \item Software development is a team sport---requires communication; misaligned specs and requirements can cause major failures (example: NASA Mars probe lost due to unit mismatch).
\end{itemize}

\subsection*{Maintaining Software}
\begin{itemize}
    \item Software is not ``write once''; it must evolve with new tech, requirements, interoperability, or bug fixes.
    \item Bugs can remain hidden for years (Linux bug example).
    \item If code isn’t designed for high cohesion/low coupling, replacements are costly and error-prone.
    \item Project failures are common (Standish Group: 19\% failure rate).
\end{itemize}

\subsection*{Why Projects Fail?}
\begin{itemize}
    \item Example: Australian Stock Exchange project failed after huge delays and poor code quality (50\% rewrite).
    \item Root causes: poor testing, bad quality management, lack of communication.
\end{itemize}

\subsection*{Software Development Process}
\begin{itemize}
    \item A systematic set of activities: requirements, design, implementation, testing/debugging, maintenance, and process management.
    \item No one-size-fits-all model; process must be adapted to context.
    \item Models are templates; engineering judgment is expected.
\end{itemize}

\subsection*{Example: Mobile Suit Development Process (Gundam)}
\begin{itemize}
    \item Steps: requirements, high-level design, approvals, detailed design, build, validation, production, maintenance, feedback.
    \item Parallels to software: staged, iterative, feedback-driven.
\end{itemize}

\subsection*{Five Main Elements in Software Development}
\begin{itemize}
    \item Requirements capture: most difficult.
    \item Design: how to meet requirements.
    \item Implementation: actual coding and documentation.
    \item Verification: testing and debugging.
    \item Operations and maintenance: post-release fixes, enhancements, refactoring.
\end{itemize}

\subsection*{Ordering and Structuring}
\begin{itemize}
    \item Waterfall: sequential, best for well-understood requirements; rarely strictly followed.
    \item All-connected: more iterative, recognizes feedback loops.
\end{itemize}

\subsection*{Process Models}
\begin{itemize}
    \item Waterfall: classic, linear.
    \item Incremental: divides work into manageable increments, can overlap.
    \item RAD: rapid, parallel, resource-intensive.
    \item Prototyping: evolutionary, fast feedback, risk of poor implementation choices.
    \item Spiral: risk-driven, evolutionary.
    \item Unified Process: iterative, incremental, flexible.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 3: Software Development (Unified Process, Agile) (\texttt{ch3.pdf})}

\subsection*{Unified Process (UP)}
\begin{itemize}
    \item \textbf{Architecture-centric:} Build executable prototypes for early validation and reuse.
    \item \textbf{Controlled iterative:} Address critical risks early, deliver in increments, gather feedback.
    \item \textbf{Use-case driven:} Requirements and design are driven by how users will interact with the system.
    \item \textbf{Tailorable:} Process can be adapted to fit project needs.
\end{itemize}

\subsection*{Inside a UP Cycle}
\begin{itemize}
    \item Inception: Feasibility, scope.
    \item Elaboration: Define architecture, plan construction, identify and prioritize risks.
    \item Construction: Build increments, prepare for deployment.
    \item Transition: Integrate, train users, make adjustments.
    \item Each phase may have multiple iterations; several cycles per project.
\end{itemize}

\subsection*{Core Practices}
\begin{itemize}
    \item Develop iteratively.
    \item Manage requirements systematically.
    \item Use proven architecture.
    \item Model requirements and user interactions.
    \item Continuously verify quality.
    \item Foster collaborative development.
\end{itemize}

\subsection*{Agile Manifesto and Principles}
\begin{itemize}
    \item \textbf{Values:} Individuals/interactions > processes/tools, working software > documentation, customer collaboration > contract negotiation, responding to change > following a plan.
    \item \textbf{Principles:} Customer satisfaction by rapid delivery, welcome change, frequent delivery, working software as progress, sustainable pace, collaboration, face-to-face communication, motivated teams, technical excellence, simplicity, self-organizing teams, regular reflection.
\end{itemize}

\subsection*{Agile Practices (XP)}
\begin{itemize}
    \item Planning game, small releases, system metaphor, simple design, testing, refactoring, pair programming, collective ownership, CI, 40-hour week, on-site customer, coding standards.
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 4: Requirements (\texttt{ch4.pdf})}

\subsection*{Why is ``requirements capture'' so important?}
\begin{itemize}
    \item \textbf{Most problems come from inadequate requirements analysis:}
        \begin{itemize}
            \item Stakeholders have different technical backgrounds, which can cause misunderstandings.
            \item Improper assumptions may be made about the system or users.
            \item Unknown characteristics of the inputs (e.g., data types, ranges) can lead to errors.
            \item Engineering concerns (how to build) often conflict with economic concerns (cost, time).
        \end{itemize}
    \item \textbf{Historical lesson:} Spending time early to clarify problems and solutions is cheaper than fixing mistakes later.
\end{itemize}

\subsection*{What is a requirement?}
\begin{itemize}
    \item Is it a process or a product? \textbf{Answer:} Both.
    \item \textbf{As a process:} All stakeholders define what the problems are and what the solution needs to include.
        \begin{itemize}
            \item Output: a document describing high-level concerns, what the software will and will not do.
            \item No concrete design at this stage.
        \end{itemize}
    \item \textbf{As a product:} The documentation resulting from the process, e.g., informal memo, formal Software Requirement Specification (SRS).
        \begin{itemize}
            \item IEEE templates (1984, 2011), ReadySET templates are mentioned as standards.
        \end{itemize}
\end{itemize}

\subsection*{Requirements vs. Specification}
\begin{itemize}
    \item \textbf{Who is the audience for SRS documents?} Both users and developers.
    \item \textbf{Requirements:} What users want, written in user language.
    \item \textbf{Specification:} How the software will meet those requirements, written for developers to answer:
        \begin{itemize}
            \item Which modules must be constructed?
            \item Should we use object-oriented design?
            \item What algorithms should be used?
        \end{itemize}
\end{itemize}

\subsection*{Example: Requirements and Specification}
\begin{itemize}
    \item \textbf{Requirements (User-focused):}
        \begin{itemize}
            \item ``An easy to use source control system that can store multiple versions of code, can rollback, able to split branches.''
        \end{itemize}
    \item \textbf{Specification (Developer-focused):}
        \begin{itemize}
            \item Must have fast algorithms for computing differences between versions.
            \item Write operations must be atomic and journaled.
            \item Must be distributed.
            \item Must be secure.
        \end{itemize}
\end{itemize}

\subsection*{Functional and Non-functional Requirements}
\begin{itemize}
    \item \textbf{Functional:} What functions the software must achieve.
    \item \textbf{Non-functional:} Constraints or system properties (e.g., security, usability, performance, memory limits, process requirements like using Jira for bug tracking).
    \item \textbf{Classification:}
        \begin{itemize}
            \item Product (protocols, encodings, encryption).
            \item Organizational (coding style, processes).
            \item External (constraints outside your control, e.g., ``must use FAX'').
        \end{itemize}
\end{itemize}

\subsection*{Systematic Requirements Collection}
\begin{itemize}
    \item Always consider all types: functional, product, organizational, and external non-functional.
\end{itemize}

\subsection*{WRSPM Reference Model}
\begin{itemize}
    \item \textbf{Purpose:} Map requirements (problem domain) to specifications (solution domain).
    \item \textbf{Components:}
        \begin{itemize}
            \item \textbf{Interface:} e.g., GUI, TUI.
            \item \textbf{Environment:}
                \begin{itemize}
                    \item W - world assumptions
                    \item R - requirements
                    \item S - specification
                \end{itemize}
            \item \textbf{System:}
                \begin{itemize}
                    \item P - program (software)
                    \item M - machine (hardware)
                \end{itemize}
            \item \textbf{Four phenomena:}
                \begin{itemize}
                    \item $e_h$: hidden elements (e.g., user skills)
                    \item $e_v$: elements visible to the system (e.g., user input)
                    \item $s_v$: shared system elements, visible to users (e.g., buttons)
                    \item $s_h$: internal representations (e.g., data structures)
                \end{itemize}
        \end{itemize}
    \item \textbf{Goals:}
        \begin{itemize}
            \item $W + S \Rightarrow R$
            \item $P + M \Rightarrow S$
            \item $W + P + M \Rightarrow R$
        \end{itemize}
\end{itemize}

\subsection*{Requirements Elicitation Techniques}
\begin{itemize}
    \item Interviews, scenarios, prototypes, observation.
\end{itemize}

\subsection*{Requirements Validation}
\begin{itemize}
    \item \textbf{Validity:} Do requirements reflect real needs?
    \item \textbf{Consistency:} Are they consistent among stakeholders and scenarios?
    \item \textbf{Completeness:} Do they solve the original problem?
    \item \textbf{Realism:} Are they achievable within budgets?
    \item \textbf{Verifiability:} How easily can we test that they are met?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 5: Source control system (\texttt{ch5.pdf})}

\subsection*{Why Source Control System is Crucial?}
\begin{itemize}
    \item \textbf{Many versions of code exist:}
        \begin{itemize}
            \item Changing requirements, bug fixes, new environments.
            \item New versions accumulate even after shipping.
        \end{itemize}
    \item \textbf{Why use a tool?}
        \begin{itemize}
            \item Maintain multiple versions (traceability, rollback).
            \item Support parallel development (different projects, same project by many devs).
            \item Resource estimation, release tracking.
        \end{itemize}
\end{itemize}

\subsection*{General Terminology}
\begin{itemize}
    \item \textbf{Repository (repo):}
        \begin{itemize}
            \item Database (can be local or remote) that stores file content and history (metadata).
        \end{itemize}
    \item \textbf{Commit:}
        \begin{itemize}
            \item A snapshot of files at a point in time; a repo is a series of commits.
        \end{itemize}
    \item \textbf{Working copy:}
        \begin{itemize}
            \item A checked-out copy of the repo at a particular commit.
        \end{itemize}
\end{itemize}

\subsection*{Source Control Evolution: RCS, CVS, Git}
\textbf{Take 1: RCS (first released 1982)}
\begin{itemize}
    \item \textbf{Requirements:}
        \begin{itemize}
            \item Keep copies of all edits, change logs, and diffs between versions.
        \end{itemize}
    \item \textbf{Specification:}
        \begin{itemize}
            \item Keep changes and logs, support rollback/diff/merge, resolve conflicts, possibly use client-server.
            \item Handle text and binary files.
        \end{itemize}
    \item \textbf{Design:}
        \begin{itemize}
            \item Each file has its own repository; no project-level repo.
            \item To release multi-file software, you must manually check out each file version and combine them.
            \item Uses ``lock-modify-unlock'': only one editor per file at a time.
            \item Teamwork is hard (no parallel edits).
        \end{itemize}
\end{itemize}

\textbf{Take 2: CVS (first released 1990)}
\begin{itemize}
    \item \textbf{Requirements:}
        \begin{itemize}
            \item All from Take 1, plus allow multiple devs to work on same files.
        \end{itemize}
    \item \textbf{Specification:}
        \begin{itemize}
            \item Each commit can contain multiple files.
            \item Support for multiple users, networked access (SSH, email), login/security.
        \end{itemize}
    \item \textbf{Design:}
        \begin{itemize}
            \item Server-client based, centralized repository.
            \item ``Copy-modify-merge-before-commit'': No locks, but you must merge with others’ changes before committing.
            \item Commits are not atomic: if two users commit at once, data corruption can result.
            \item File versions are still tracked individually; a commit may contain fileA v1.4 and fileB v1.3.
            \item Branching and renaming are difficult and error-prone.
        \end{itemize}
\end{itemize}

\textbf{Take 3: Git (first released 2005)}
\begin{itemize}
    \item \textbf{Requirements:}
        \begin{itemize}
            \item All from Take 2, plus: assign same version number to all files in a snapshot.
        \end{itemize}
    \item \textbf{Specification:}
        \begin{itemize}
            \item Distributed repository: every user has a full copy.
            \item Commits are atomic (all-or-nothing).
            \item Branching is fast and easy.
            \item Better support for renaming, compression, and diffs.
            \item Same version applies to all files in a commit.
        \end{itemize}
    \item \textbf{Design:}
        \begin{itemize}
            \item ``Copy-modify-commit-before-merge'': You can commit locally without merging others’ changes, then merge later.
            \item The concept of ``staging'' allows preparing and splitting commits as needed.
            \item Central repo is still used for integration, CI/CD, and backup.
            \item More complex concepts (local vs remote repo, staging area, etc.).
        \end{itemize}
\end{itemize}

\subsection*{Branching Strategies}
\begin{itemize}
    \item \textbf{Trunk-only:}
        \begin{itemize}
            \item Only one main branch. Simple, but causes merge conflicts and makes feature exclusion difficult.
        \end{itemize}
    \item \textbf{Feature branching:}
        \begin{itemize}
            \item One branch per feature or hotfix.
            \item Frequent merges from main to feature branches.
            \item ``Pull requests'' are used for code reviews before merging.
            \item Short-lived branches are best; long-lived branches lead to hard-to-resolve conflicts.
            \item Naming conventions (e.g., feature/\textless ticket\_id\textgreater/description) are recommended.
        \end{itemize}
    \item \textbf{More complex branching:}
        \begin{itemize}
            \item Multiple long-lived branches (e.g., main, dev) are possible, but require robust CI/CD.
        \end{itemize}
\end{itemize}

\subsection*{Do’s and Don’ts}
\begin{itemize}
    \item \textbf{Do:}
        \begin{itemize}
            \item Delete branches after merging.
            \item Communicate regularly.
            \item Keep branch scope limited.
            \item Use clear, consistent naming.
        \end{itemize}
    \item \textbf{Don’t:}
        \begin{itemize}
            \item Keep branches forever.
            \item Work in isolation (causes merge conflicts).
            \item Push code that cannot be compiled.
        \end{itemize}
\end{itemize}

\subsection*{Git Commands and Concepts}
\begin{itemize}
    \item Common commands: clone, pull, fetch, merge, rebase, stash, subtree, submodule, remote, add, rm, commit, push, branch, checkout, diff, difftool.
    \item \textbf{merge vs rebase:}
        \begin{itemize}
            \item \textbf{merge:} Combines branches, preserving all history and showing where they diverged.
            \item \textbf{rebase:} Moves a branch to begin on the tip of another branch, making history linear.
        \end{itemize}
\end{itemize}

\subsection*{Other Tools and Practices}
\begin{itemize}
    \item Communication and tooling (IDE, CI/CD, automated tests) are crucial.
    \item \textbf{Feature flags:} Boolean variables in code for toggling features at runtime, helpful for testing and release management.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 6: Software architecture (\texttt{ch6.pdf})}

\subsection*{What is software architecture?}
\begin{itemize}
    \item \textbf{Definition (Carnegie-Mellon SEI):} 
    \begin{quote}
        ``The architecture of a software-intensive system is the structure or structures of the system, which comprise software elements, the externally-visible properties of those elements, and the relationships among them.''
    \end{quote}
    \item \textbf{Purpose:} Partition large systems into smaller subsystems/modules to achieve:
        \begin{itemize}
            \item Reusability
            \item Testability
            \item Manageability
            \item Integratability
            \item Scalability
            \item Security
            \item Usability
            \item Performance
            \item Code elegance
        \end{itemize}
    \item \textbf{References:} IEEE 42010, software architecture documentation frameworks.
    \item \textbf{Key lesson:} Bad architecture can't be fixed by good coding later (e.g. a cryptocurrency network with centralized nodes undermines the whole purpose).
\end{itemize}

\subsection*{Decomposition}
\begin{itemize}
    \item \texttt{decompose(software system) -> components}:
        \begin{itemize}
            \item Each component should be self-contained, independently constructible, and have its own business value.
            \item Enables better organization, parallel development, third-party integration, and subsystem cooperation.
        \end{itemize}
    \item Decomposition is recursive: you can decompose classes into methods, packages into classes, subsystems into packages, and systems into subsystems.
\end{itemize}

\subsection*{What must a component have?}
\begin{itemize}
    \item A clearly defined set of responsibilities (e.g., UI logic separate from business logic).
    \item A clearly defined boundary (no shared internal data or responsibilities with other components).
    \item A set of well-defined interfaces (APIs) for interconnection.
\end{itemize}

\subsection*{Architectural structuring}
\begin{itemize}
    \item Define a \textbf{static hierarchy} of interacting components.
    \item Also define the \textbf{dynamic behavior} (runtime interaction) between components.
\end{itemize}

\subsection*{High-level system structures}
\begin{itemize}
    \item \textbf{Client-server}
    \item \textbf{Layered}
    \item \textbf{Blackboard}
    \item \textbf{Pipe-and-filter}
    \item \textbf{Event-driven}
    \item Often, real systems are a mix of these.
\end{itemize}

\subsection*{Client-server}
\begin{itemize}
    \item Distributed components provide services to clients.
    \item Example code: 
    \begin{verbatim}
def collect_news_from_news_server(sym: str) -> str:
    return f"No news about {sym} is good news"

def collect_price_history_from_archive_server(sym: str) -> list[float]:
    return [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 0.7]

def magic_calc_price_by_news_price_history(
    sym: str, news: str, price_history: list[float]
) -> float:
    if news.find("good"):
        return statistics.mean(price_history) + statistics.stdev(price_history)
    else:
        return statistics.mean(price_history) - statistics.stdev(price_history)

def calc_stock_price(sym: str) -> float:
    news: str = collect_news_from_news_server(sym)
    price_history: list[float] = collect_price_history_from_archive_server(sym)
    return magic_calc_price_by_news_price_history(sym, news, price_history)
    \end{verbatim}
    \item \textbf{Explanation:} The code is illustrative; `collect_news_from_news_server` and `collect_price_history_from_archive_server` represent the server side, while `calc_stock_price` is the client logic that uses the information.
\end{itemize}

\subsection*{Layered}
\begin{itemize}
    \item System is organized in layers, each supporting and depending on the one above/below.
    \item Example: Library checkout system.
    \item \textbf{Business logic layer} (\texttt{Library}, \texttt{CheckoutRule}, \texttt{Notification} classes): Implements the actual behaviors.
    \item \textbf{Facade layer} (\texttt{LibraryFacade}): Provides a simple interface for application use.
    \item \textbf{Application layer}: Instantiates the facade and performs actions.
    \item \textbf{Explanation:} Each layer abstracts and hides details from the layer above. This allows for replacing or reusing layers independently.
\end{itemize}

\subsection*{Blackboard}
\begin{itemize}
    \item Used for complex, multi-domain problems (e.g., IDEs, speech recognition).
    \item Components:
        \begin{itemize}
            \item \textbf{Blackboard}: Shared data, problem state.
            \item \textbf{Knowledge Sources}: Sub-problem solvers.
            \item \textbf{Control Shell}: Orchestrates the process.
        \end{itemize}
    \item Example: Counting from 0 to 10 using blackboard approach (see code in chapter).
    \item \textbf{Explanation:} Each knowledge source reads from and writes to the blackboard; the control shell coordinates which sources act.
\end{itemize}

\subsection*{Pipe-and-filter}
\begin{itemize}
    \item Data flows through a series of filters (transformers); each filter processes data and passes it on.
    \item Example: Linux pipeline \texttt{fortune | cowsay | tee saved\_cowsay.txt}.
    \item Useful for sequential or parallel transformations, and for reusability.
\end{itemize}

\subsection*{Event-driven}
\begin{itemize}
    \item Producers push data into a message broker (e.g., RabbitMQ, Kafka).
    \item Consumers listen for events and act.
    \item Example: Web app produces events; services listen and process them.
    \item Useful for highly decoupled and scalable systems.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 7: Software architecture 2 (\texttt{ch7.pdf})}

\subsection*{Recap: What must a component have?}
\begin{itemize}
    \item Clearly defined responsibilities.
    \item Clearly defined boundary.
    \item Well-defined interfaces.
    \item \textbf{Ultimate goal:} Loosely coupled system $\rightarrow$ high reusability, testability, manageability, scalability, etc.
\end{itemize}

\subsection*{Client-server: When and why?}
\begin{itemize}
    \item \textbf{When to use:}
        \begin{itemize}
            \item Centralized resource management (e.g., user DB, access control).
            \item Many clients accessing shared resources.
            \item Heterogeneous clients (laptops, mobile, bots).
        \end{itemize}
    \item \textbf{Potential issues:}
        \begin{itemize}
            \item Server failure disables all clients.
            \item Security: requires authentication and authorization for remote access.
        \end{itemize}
    \item \textbf{Misconceptions:}
        \begin{itemize}
            \item Server is not always remote.
            \item Communication isn't always network-based (example: Docker, where \texttt{docker} client and \texttt{dockerd} server run on same machine via IPC socket).
        \end{itemize}
\end{itemize}

\subsection*{Layered: When and why?}
\begin{itemize}
    \item \textbf{When to use:}
        \begin{itemize}
            \item Functions can be abstracted recursively into levels.
            \item Standardization needed (e.g., OSI 7-layer model).
            \item Flexibility needed (replace a layer's implementation).
            \item Reusability needed.
        \end{itemize}
    \item \textbf{Potential issues:}
        \begin{itemize}
            \item Abstraction may reduce efficiency (e.g., many function calls, added headers in network stacks).
            \item Local changes may propagate to higher layers, indicating a bad layering scheme.
        \end{itemize}
    \item \textbf{Example:}
        \begin{itemize}
            \item Two Python versions of an OR gate: one composed of many small layered functions (slower), the other more direct (faster).
        \end{itemize}
\end{itemize}

\subsection*{Blackboard: When and why?}
\begin{itemize}
    \item \textbf{When to use:}
        \begin{itemize}
            \item Problem can be divided into sub-problems.
            \item No deterministic overall solution, but sub-problems are tractable.
            \item Partial knowledge or large search space.
            \item Want to try different algorithms with reusable components.
        \end{itemize}
    \item \textbf{Potential issues:}
        \begin{itemize}
            \item Testing is difficult (results not reproducible).
            \item High development effort (complex control strategy).
        \end{itemize}
\end{itemize}

\subsection*{Pipe-and-filter: When and why?}
\begin{itemize}
    \item \textbf{When to use:}
        \begin{itemize}
            \item Standardized input/output formats.
            \item High reusability and flexibility (components reusable and reorderable).
            \item Rapid prototyping needed.
        \end{itemize}
    \item \textbf{Potential issues:}
        \begin{itemize}
            \item Passing large data along the pipeline can be expensive.
            \item For maximum flexibility, all filters must use the same format, which increases conversion overhead.
        \end{itemize}
\end{itemize}

\subsection*{Event-driven (Broker): When and why?}
\begin{itemize}
    \item \textbf{When to use:}
        \begin{itemize}
            \item System is highly decoupled or distributed.
            \item Super scalability is required.
            \item Components just need to know message format, not server locations or APIs.
            \item Cross-platform communication is needed.
        \end{itemize}
    \item \textbf{Potential issues:}
        \begin{itemize}
            \item Less efficient due to indirections.
            \item Easy to overuse because it sounds so flexible.
        \end{itemize}
    \item \textbf{Examples:}
        \begin{itemize}
            \item Intra-process: Qt's "signals and slots".
            \item Inter-process/network: Apache Kafka, RabbitMQ, Faststream for Python.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 8: Introduction to Risk Analysis: Fault Tree Analysis (\texttt{ch8.pdf})}

\subsection*{Risk analysis: Why?}
\begin{itemize}
    \item \textbf{Mistakes are inevitable:} Planning for mistakes is essential in software engineering.
    \item \textbf{Testing is limited:} Can detect bugs, but cannot prove absence of all bugs.
    \item \textbf{All components are unreliable:} Some more so than others. This mindset is important for robust system design.
    \item \textbf{Risk/Safety analysis:} Required in certain standards (e.g., ARP4761 for aerospace).
\end{itemize}

\subsection*{Use cases for risk analysis}
\begin{itemize}
    \item Identify risks.
    \item Predict failure probability and system reliability.
    \item Prioritize tasks based on risk.
    \item Provide documented analysis for stakeholders.
    \item Checklist for architecture design.
    \item Define system metrics and rubrics.
    \item Debugging support.
\end{itemize}

\subsection*{Fault Tree Analysis (FTA): What and how?}
\begin{itemize}
    \item \textbf{Definition:} A graphical and mathematical method for predicting the causes and likelihood of system failures.
    \item \textbf{Origins:} Developed in the 1960s for launch control systems.
    \item \textbf{Output:} 
        \begin{itemize}
            \item \textbf{Qualitative:} Minimal combinations of failure causes.
            \item \textbf{Quantitative:} Probabilities of failures.
        \end{itemize}
    \item \textbf{Method:} Model a system fault as a tree of events, where each event is caused by other events, linked by logic gates (AND, OR).
\end{itemize}

\subsection*{Example of a Fault Tree}
\begin{itemize}
    \item \textbf{Scenario:} ``Safety system fails to respond" is the top event.
    \item \textbf{Branches:} 
        \begin{itemize}
            \item Failure to detect heat (linked to heat detector or security guard fails to wake up).
            \item Failure to detect smoke (linked to smoke detector or fire detection system).
        \end{itemize}
    \item \textbf{Explanation:} Each branch represents logical dependencies; AND/OR gates model how failures combine.
\end{itemize}

\subsection*{Fault tree construction: Rules}
\begin{itemize}
    \item \textbf{Top event:} System failure mode.
    \item \textbf{Basic events:} Leaf-level component failures.
    \item \textbf{Gates:} AND/OR logic connects events.
    \item \textbf{Procedure:} Recursively break down system failures until only basic events remain.
    \item \textbf{Rules:} 
        \begin{itemize}
            \item Assume component failures propagate and become observable (no cancellations).
            \item Define all gate inputs before expanding further (breadth-first).
            \item Gates should not connect directly to other gates.
        \end{itemize}
\end{itemize}

\subsection*{Second Fault Tree Example: Ineffective security}
\begin{itemize}
    \item \textbf{Top event:} Ineffective security.
    \item \textbf{Branches:} Weak password, broken encryption.
    \item \textbf{Sub-branches:} Password length, specific weak password, weak encryption algorithm, short encryption key.
    \item \textbf{Symbols:} Top event = logic gate; failure event = internal node; basic failure event = leaf.
\end{itemize}

\subsection*{Minimal cut set}
\begin{itemize}
    \item \textbf{Definition:} A (minimal) set of basic events whose occurrence guarantees the top event (system failure).
    \item \textbf{Example:} For the security tree, minimal cut sets are: 
        \begin{itemize}
            \item Both short encryption key \textbf{and} weak encryption algorithm.
            \item Password length too short.
            \item Password is "12345678".
        \end{itemize}
    \item \textbf{Boolean representation:} Each basic event is a Boolean variable ($a$, $b$, $c$, $d$). The top event formula might be $ab + c + d$.
\end{itemize}

\subsection*{System failure probability}
\begin{itemize}
    \item For each minimal cut set $C_i$ (composed of independent events $X_{ij}$): $P(C_i) = \prod_{j} P(X_{ij})$
    \item The top event's probability is bounded above by the sum of cut set probabilities: $P(\text{top event}) \leq \sum_i P(C_i)$.
    \item Alternatively, $P(\text{top event}) \leq 1 - \prod_i (1-P(C_i))$.
    \item \textbf{Note:} Only the upper bound is usually practical to compute, since overlapping of cut sets is complex.
\end{itemize}

\subsection*{Importance measures}
\begin{itemize}
    \item \textbf{Purpose:} Quantify how much each component contributes to system failures.
    \item \textbf{Critical system state:} For each component, a "critical state" is when all other components are in a specific state such that failure of this component alone causes system failure.
    \item \textbf{Example:} Table shows for each combination of other components, whether a specific component is critical.
\end{itemize}

\subsection*{Structural importance measure}
\begin{itemize}
    \item \textbf{Definition:} Number of critical states for a component divided by total number of states.
    \item \textbf{Calculation:} For the example, $a$ and $b$ each have $1/8$; $c$ and $d$ have $3/8$.
    \item \textbf{Interpretation:} Focus on improving the most critical components (highest measure) to boost system reliability.
    \item Probabilistic measures can refine this further by considering failure probabilities.
\end{itemize}

\subsection*{Further references}
\begin{itemize}
    \item Handbook of Software Reliability Engineering, Chapter 15.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 9: Software design: Introduction (\texttt{ch9.pdf})}

\subsection*{What is software design?}
\begin{itemize}
    \item \textbf{Definition:} 
        \begin{itemize}
            \item \textbf{Process:} Steps taken to move from requirements to implementation.
            \item \textbf{Product:} The output artifacts (design documents, diagrams, pseudocode, etc.).
        \end{itemize}
    \item \textbf{Stages of design:}
        \begin{itemize}
            \item Understanding the problem.
            \item Identifying solutions.
            \item Describing solution abstractions (technology-independent, e.g., UML).
        \end{itemize}
    \item \textbf{Diagram:} Shows flow from requirements $\to$ specification $\to$ architecture $\to$ design $\to$ implementation.
    \item \textbf{Iteration:} Each stage may reveal new problems or abstractions, requiring revisiting earlier stages.
\end{itemize}

\subsection*{Architecture vs. Design}
\begin{itemize}
    \item \textbf{Architecture:}
        \begin{itemize}
            \item High-level structure of the system.
            \item What are the main components, their responsibilities, and APIs.
        \end{itemize}
    \item \textbf{Design:}
        \begin{itemize}
            \item Internal structure of components (classes, data structures, algorithms).
            \item No code yet, just detailed blueprints.
        \end{itemize}
\end{itemize}

\subsection*{Design process example: Fibonacci}
\begin{itemize}
    \item \textbf{Problem:} Implement $f(n) = f(n-1) + f(n-2)$, with $f(0)=1$, $f(1)=1$.
    \item \textbf{Solution options:}
        \begin{itemize}
            \item \textbf{Iterative pseudocode:}
                \begin{itemize}
                    \item Initialize an array for previous/current values.
                    \item Shift and update values in a loop.
                \end{itemize}
            \item \textbf{Recursive pseudocode:}
                \begin{itemize}
                    \item If $n=0$ return 0; if $n=1$ return 1; else return $f(n-1) + f(n-2)$.
                \end{itemize}
        \end{itemize}
    \item \textbf{Analysis:}
        \begin{itemize}
            \item Iterative: efficient, no repeated work.
            \item Recursive: simple, but wastes memory and time on repeated calls.
        \end{itemize}
    \item \textbf{Design output:} Pseudocode, technology-independent, is enough for direct implementation.
    \item \textbf{Implementation:} Actual code (Python) can differ from pseudocode for efficiency.
\end{itemize}

\subsection*{Essentials of a good design}
\begin{itemize}
    \item \textbf{Divide and conquer:} Break system into subsystems (which have business value) and modules (smaller, internal units).
    \item \textbf{Single responsibility:} Each component should only have one job.
    \item \textbf{Loose coupling:} Components can be easily swapped; changes don't ripple through the system.
    \item \textbf{High cohesion:} Functions and data in a component work tightly together towards a single goal.
    \item \textbf{Information hiding:} Details are hidden behind clear interfaces.
    \item \textbf{Data encapsulation:} Only expose what's necessary.
\end{itemize}

\subsection*{Coupling}
\begin{itemize}
    \item \textbf{Definition:} How strongly components depend on each other.
    \item \textbf{Desirable:} Loose coupling (easy substitution, minimal change ripple).
    \item \textbf{Types:}
        \begin{itemize}
            \item \textbf{Tight:} Content coupling (directly manipulating another's data), Common coupling (global data), External coupling (depends on uncontrollable components, e.g., DB vendor).
            \item \textbf{Medium:} Control coupling (passing control flags), Data structure/stamp coupling (sharing data structures but only using part).
            \item \textbf{Loose:} Data coupling (only data passed via parameters), Message coupling (interaction only via messages, as in event-driven systems).
        \end{itemize}
    \item \textbf{Examples:}
        \begin{itemize}
            \item Code examples for each type are given (e.g., user/card classes for content coupling, global counter for common coupling, etc.).
        \end{itemize}
\end{itemize}

\subsection*{Cohesion}
\begin{itemize}
    \item \textbf{Definition:} How well the elements of a component belong together.
    \item \textbf{High cohesion:} All internal data/functions are essential; no unused elements; ideally, each function uses all attributes.
    \item \textbf{Guideline:} ``Put only closely related code together as a unit.''
    \item \textbf{Goal:} Each unit should have a single clear responsibility and no code duplication.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 10: High level design strategies, and considerations in the design process (\texttt{ch10.pdf})}

\subsection*{Design at different levels}
\begin{itemize}
    \item \textbf{After requirements:} Multiple levels of design must be performed:
        \begin{itemize}
            \item \textbf{Architectural Design:} How to divide the entire system into subsystems/modules?
            \item \textbf{Interface Design:} What are the inputs/outputs for each subsystem or module? How do they interact? What is the user interface?
            \item \textbf{Component Design:} How can a subsystem/module be decomposed further? How do submodules and data structures interact?
            \item \textbf{Data Design:} What are the formats of data to be consumed/produced?
            \item \textbf{Algorithm Design:} How are data structures and algorithms used to implement functions?
        \end{itemize}
    \item \textbf{Note:} In practice, these are often considered simultaneously.
\end{itemize}

\subsection*{High-level design strategies}
\begin{itemize}
    \item \textbf{Top-down vs. bottom-up}
        \begin{itemize}
            \item \textbf{Top-down:} Start from the root abstraction, decompose into finer levels. Organized, but real design rarely purely top-down.
            \item \textbf{Bottom-up:} Identify essential standalone components, assemble into a complete system. Allows distributed development, but needs big picture planning.
        \end{itemize}
    \item \textbf{Centralised vs. decentralised} (in this context: how you conceptualize the architecture, not deployment)
\end{itemize}

\subsection*{Top-down design example: Song composition}
\begin{itemize}
    \item Steps: Select a key; think about song structure; develop melody/chords for each section.
\end{itemize}

\subsection*{Bottom-up design example: Song composition}
\begin{itemize}
    \item Steps: Develop melodic/chord riffs; adjust riffs for consistency; join riffs using chord progressions.
\end{itemize}

\subsection*{Centralised design}
\begin{itemize}
    \item \textbf{Start:} Model the system from one component's perspective (e.g., the library system itself).
    \item \textbf{Example:} 
        \begin{verbatim}
class LibrarySystem:
    def __init__(self):
        self.borrow_records = BorrowRecords()
    def checkout(self, user: User, books : [Book]):
        self.borrow_records.add(user, books)
        \end{verbatim}
    \item \textbf{Explanation:} The system evolves as you realize new required components (BorrowRecords, User, Book).
\end{itemize}

\subsection*{Distributed design}
\begin{itemize}
    \item \textbf{Start:} Identify all ``nouns'' (major objects/actors, e.g., User, Book).
    \item \textbf{Example:} 
        \begin{verbatim}
class User:
    def __init__(self):
        self._borrowed_books = []
    def borrow_book(self, book: "Book"):
        self._borrowed_books.append(book)
        book.lend(self)
class Book:
    def __init__(self):
        self._borrower = None
    def lend(self, user: User):
        self._borrower = user
        \end{verbatim}
    \item \textbf{Explanation:} Each object manages its own state; interactions are through method calls.
\end{itemize}

\subsection*{Which design is better?}
\begin{itemize}
    \item \textbf{Desirable properties at all levels:}
        \begin{itemize}
            \item Loose coupling
            \item High cohesion
            \item Information hiding
            \item Data encapsulation
            \item Fulfils all requirements
        \end{itemize}
    \item \textbf{Trade-offs:} Sometimes decoupling adds complexity and overhead; balance is needed.
\end{itemize}

\subsection*{Software design metrics}
\begin{itemize}
    \item \textbf{Metrics exist:} (e.g., coupling metric)
    \item \textbf{Tools:} Some IDEs (Visual Studio, etc.) provide quality measurement.
    \item \textbf{Instinct:} Developing good judgment is key, not just metrics.
\end{itemize}

\subsection*{Learning from examples}
\begin{itemize}
    \item Reference: ``The Architecture of Open Source Applications'' (book).
\end{itemize}

\subsection*{Warning: Overengineering}
\begin{itemize}
    \item \textbf{Don't overengineer:} Avoid ``Builder's Trap'' (spending too much time on architecture at the expense of shipping working software).
    \item \textbf{Meme:} Overengineering is a killer; a simple, working product is better than a complex, unfinished one.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 11: Object-oriented programming (OOP) in Python (\texttt{ch11.pdf})}

\subsection*{Why classes and OOP?}
\begin{itemize}
    \item Model real-world entities as objects (classes define types, attributes, methods).
    \item Promotes reusability, data abstraction, encapsulation.
\end{itemize}

\subsection*{What is OOP?}
\begin{itemize}
    \item Groups related fields (attributes) and procedures (methods) as objects.
    \item Models intuitive real-world relationships (e.g., social media accounts that follow/message each other).
\end{itemize}

\subsection*{Four pillars of OOP}
\begin{itemize}
    \item \textbf{Encapsulation:} Expose only essential info, restrict direct data access.
    \item \textbf{Abstraction/Information hiding:} Hide details, modularize code.
    \item \textbf{Inheritance:} Share common code/behavior, enable reuse.
    \item \textbf{Polymorphism:} Change behavior while keeping common interfaces.
\end{itemize}

\subsection*{Encapsulation}
\begin{itemize}
    \item Data and methods are bundled into objects; data is accessed intentionally via methods.
    \item Example: Ticket website tracks tickets sold/available internally.
    \item Python uses conventions (\texttt{\_attr}) for ``private'' fields.
\end{itemize}

\subsection*{Python class example: Social Media}
\begin{verbatim}
class Post:
    def __init__(self, post_id: str):
        self._post_id = post_id
        self._content = ""
    def update_content(self, content: str):
        self._content = content

class SocialMediaAccount:
    def __init__(self, account_id: str, username: str):
        self._account_id = account_id
        self.username = username
        self._following: set[SocialMediaAccount] = set([])
        self._posts: list[Post] = []
    def add_to_following(self, another_account: "SocialMediaAccount"):
        self._following.add(another_account)
    def add_post(self, post: Post):
        self._posts.append(post)
\end{verbatim}
\begin{itemize}
    \item \textbf{Explanation:} Shows encapsulation (private attributes), public methods, and object relationships.
\end{itemize}

\subsection*{UML class diagram notation}
\begin{itemize}
    \item \textbf{Visibility:} Private (-), Public (+), Protected (\#), Package (~).
\end{itemize}

\subsection*{Abstraction/Information hiding}
\begin{itemize}
    \item Hide internal workings; provide simple, clear interfaces.
    \item Achieved via system modularization and easy-to-use function interfaces.
\end{itemize}

\subsection*{Class vs. object/instance}
\begin{itemize}
    \item \textbf{Class:} Blueprint for objects; defines data and behavior.
    \item \textbf{Object/Instance:} Concrete realization of a class.
\end{itemize}

\subsection*{Instance creation and usage}
\begin{verbatim}
class Cat:
    def __init__(self):
        self.name = 'Kitty'
        self.breed = 'domestic short hair'
        self.age = 1
    def print_info(self):
        print(self.name, 'is a ', self.age, 'yr old', self.breed)
pet_1 = Cat()
pet_2 = Cat()
\end{verbatim}
\begin{itemize}
    \item \textbf{Explanation:} Demonstrates instantiation, attribute assignment, and method invocation.
\end{itemize}

\subsection*{Instance vs. class attributes}
\begin{verbatim}
class CoffeeOrder:
    loc = "Cafe Coffee"
    cls_id = 1
    def __init__(self):
        self.order_id = CoffeeOrder.cls_id
        self.cup_size = 16
        CoffeeOrder.cls_id += 1
    def print_order(self):
        print(CoffeeOrder.loc, "Order", self.order_id, ":", self.cup_size, "oz")
order_1 = CoffeeOrder()
order_2 = CoffeeOrder()
order_3 = CoffeeOrder()
order_3.print_order()
\end{verbatim}
\begin{itemize}
    \item \textbf{Explanation:} Class attributes (\texttt{loc}, \texttt{cls\_id}) are shared; instance attributes are unique to each object.
\end{itemize}

\subsection*{Object instantiation and initialization}
\begin{itemize}
    \item \textbf{Steps:}
        \begin{itemize}
            \item Creation: \_\_new\_\_ allocates memory.
            \item Initialization: \_\_init\_\_ sets attributes.
        \end{itemize}
    \item \textbf{Destructor:} \_\_del\_\_ cleans up resources.
    \item \textbf{Singleton example:} \_\_new\_\_ can be used to implement a singleton pattern.
\end{itemize}

\subsection*{Class methods and static methods}
\begin{verbatim}
class Person:
    @classmethod
    def new_with_name_age(cls, name, age):
        return cls(name, age)
    @staticmethod
    def create_with_name_age(name, age):
        return Person(name, age)
\end{verbatim}
\begin{itemize}
    \item \textbf{Explanation:} Class methods operate on the class; static methods do not access class or instance state.
\end{itemize}

\subsection*{Instance methods}
\begin{verbatim}
class ProductionCar:
    def update_max(self, speed):
        self.max_mph = speed
\end{verbatim}
\begin{itemize}
    \item \textbf{Explanation:} Instance methods operate on object state.
\end{itemize}

\subsection*{Inheritance}
\begin{itemize}
    \item \textbf{Is-a relationship:} Subclass inherits from superclass (e.g., \texttt{class Daisy(Plant):}).
    \item \textbf{Has-a relationship:} Composition (e.g., Employee has a Laptop).
    \item \textbf{Terminology:} Superclass/parent/base, subclass/child/derived.
    \item \textbf{Access:} Subclasses access public/protected, but not private, members.
\end{itemize}

\subsection*{OOP: Inheritance example}
\begin{verbatim}
class SuperClass:
    def __init__(self):
        self.feat_1 = 1
        self.feat_2 = ""
    def bc_display(self):
        print(f"Superclass: {self.feat_2}")

class SubClass(SuperClass):
    def dc_display(self):
        print(f"Subclass: {self.feat_2}")
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 12: Software design: Design Patterns (\texttt{ch12.pdf})}

\subsection*{What is a pattern?}
\begin{itemize}
    \item The idea comes from architect Christopher Alexander, who defined a pattern as a three-part rule: context, problem, and solution.
    \item In software, a pattern is ``a solution to a problem in a context'' and can be applied to many disciplines.
\end{itemize}

\subsection*{Why patterns?}
\begin{itemize}
    \item Designing reusable object-oriented software is hard (Erich Gamma).
    \item Experienced designers reuse successful solutions (patterns).
    \item Recognizing and naming recurring structures (patterns) increases productivity and flexibility.
\end{itemize}

\subsection*{Software patterns history}
\begin{itemize}
    \item 1987: Cunningham and Beck apply Alexander’s ideas in Smalltalk.
    \item 1990-1995: ``Gang of Four'' (Gamma, Helm, Johnson, Vlissides) publish the seminal book \emph{Design Patterns}.
    \item 1991+: Patterns community forms (Hillside Group, PLoP conference, etc).
\end{itemize}

\subsection*{Types and levels of software patterns}
\begin{itemize}
    \item \textbf{Types:} Analysis, design, organizational, process, project planning, configuration management.
    \item \textbf{Levels:} Abstract (entire systems), mid-level (GoF design patterns), concrete (e.g., linked list).
\end{itemize}

\subsection*{GoF Design Patterns}
\begin{itemize}
    \item \textbf{Purpose:}
        \begin{itemize}
            \item Creational: how objects are created.
            \item Structural: composition of classes/objects.
            \item Behavioral: interactions among classes/objects.
        \end{itemize}
    \item \textbf{Scope:}
        \begin{itemize}
            \item Class patterns: inheritance (class relationships).
            \item Object patterns: composition (object relationships).
        \end{itemize}
\end{itemize}

\subsection*{GoF pattern template}
\begin{itemize}
    \item Pattern Name and Classification
    \item Intent (purpose)
    \item Also Known As (aliases)
    \item Motivation (scenario)
    \item Applicability (where to use)
    \item Structure (diagram)
    \item Participants (classes/objects involved)
    \item Collaborations (how they interact)
    \item Consequences (pros/cons)
    \item Implementation (how to code it)
    \item Sample Code
    \item Known Uses
    \item Related Patterns
\end{itemize}

\subsection*{Benefits of design patterns}
\begin{itemize}
    \item Capture and communicate expertise.
    \item Provide a shared vocabulary.
    \item Encourage reuse and avoid poor alternatives.
    \item Facilitate change and documentation.
\end{itemize}

\subsection*{Factory Patterns (Creational)}
\begin{itemize}
    \item \textbf{Factory patterns} abstract object creation, hiding details and allowing system independence from concrete classes.
    \item \textbf{Factory Method:} Lets subclasses decide which class to instantiate by defining a method for object creation, which subclasses override.
\end{itemize}

\subsection*{Factory Method Example}
\begin{itemize}
    \item \textbf{Motivation:} Framework with an Application class and Document classes; subclasses instantiate appropriate Document via a factory method.
    \item \textbf{Structure:}
        \begin{verbatim}
Creator
  +create_product() -> Product
Product
  +open()
  +close()
  ...
ConcreteProduct, ConcreteCreator implement interface
        \end{verbatim}
    \item \textbf{Usage:} Code can work with Creator and Product interfaces, and concrete subclasses provide actual classes.
    \item \textbf{Refactored:} Application has a create_document() factory method; MyApplication overrides it to create MyDocument, YourApplication creates YourDocument, etc.
\end{itemize}

\subsection*{Factory Method: Participants/Collaborations}
\begin{itemize}
    \item \textbf{Product:} Interface for objects created by the factory.
    \item \textbf{ConcreteProduct:} Implements Product.
    \item \textbf{Creator:} Declares the factory method returning Product.
    \item \textbf{ConcreteCreator:} Overrides factory method to return ConcreteProduct.
\end{itemize}

\subsection*{Factory Method: Consequences}
\begin{itemize}
    \item \textbf{Benefits:} Decouples code from specific classes, makes code reusable/flexible.
    \item \textbf{Liabilities:} May require subclassing for each new Product.
    \item \textbf{Implementation:} Factory method can be abstract or concrete; may take parameters to decide what to instantiate.
\end{itemize}

\subsection*{Abstract Factory Pattern}
\begin{itemize}
    \item Provides an interface for creating families of related objects without specifying concrete classes.
    \item Difference from Factory Method: delegates instantiation to a factory object (composition), not just a subclass (inheritance).
\end{itemize}

\subsection*{Abstract Factory Example}
\begin{itemize}
    \item \textbf{GUI toolkit:} WidgetFactory creates ScrollBar and Window; MotifWidgetFactory creates MotifScrollBar/MotifWindow, PMWidgetFactory creates PMScrollBar/PMWindow.
    \item \textbf{MazeFactory:} MazeGame uses a MazeFactory to create rooms, walls, doors; can swap in EnchantedMazeFactory, etc.
    \item \textbf{Structure:}
        \begin{verbatim}
AbstractFactory
  +create_product_a()
  +create_product_b()
ConcreteFactory1
  +create_product_a()
  +create_product_b()
...
Client uses AbstractFactory/AbstractProduct interfaces
        \end{verbatim}
\end{itemize}

\subsection*{Abstract Factory: Consequences}
\begin{itemize}
    \item Isolates clients from concrete classes.
    \item Makes swapping product families easy.
    \item Enforces use of only one family at a time.
    \item \textbf{Liabilities:} Can become complex; adding new products requires interface changes.
    \item \textbf{Implementation:} Typically a singleton; factories use factory methods to create products.
\end{itemize}

\subsection*{Singleton Pattern}
\begin{itemize}
    \item Ensures a class has only one instance, provides a global point of access.
    \item Motivation: e.g., window manager, resource manager, factory.
    \item Structure: static instance variable, static factory method.
    \item Implemented in Python using \_\_new\_\_ or metaclasses; care required for thread safety and to prevent direct instantiation.
\end{itemize}

\subsection*{Adapter Pattern}
\begin{itemize}
    \item Converts the interface of a class into another expected by clients.
    \item \textbf{Class Adapter:} Uses multiple inheritance; Adapter inherits from Target and Adaptee.
    \item \textbf{Object Adapter:} Uses composition; Adapter holds an Adaptee and implements Target.
    \item \textbf{Applicability:} Use when you need to work with an existing class but its interface is incompatible.
    \item \textbf{Implementation:} May adapt a single method or a full interface; can provide two-way adaptation if needed.
\end{itemize}

\subsection*{Adapter Examples}
\begin{itemize}
    \item \textbf{Round peg / square peg:} Adapts different interfaces for insertion.
    \item \textbf{Two-way adapter:} Implements both interfaces (via abstract base class).
    \item \textbf{Selective copying:} Adapts objects to a Copyable interface for a utility.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 13: Software design: Design Patterns 2 (\texttt{ch13.pdf})}

\subsection*{Composite Pattern}
\begin{itemize}
    \item \textbf{Intent:} Compose objects into tree structures to represent part-whole hierarchies; treat individual objects and compositions uniformly (recursive composition).
    \item \textbf{Structure:}
        \begin{verbatim}
Component
  +operation()
  +add(), +remove(), +get_child()
Leaf
  +operation()
Composite
  +children: [Component]
  +operation(), +add(), +remove(), +get_child()
        \end{verbatim}
    \item \textbf{Example:} Graphics (Line, Rectangle, Picture, etc.); GUI widgets (Windows, Buttons, Containers).
    \item \textbf{Benefits:} Easy to add new components; clients can treat all as Components.
    \item \textbf{Liabilities:} Over-generalization if classes differ too much; may waste space if every leaf has a children list.
\end{itemize}

\subsection*{Composite Pattern: Implementation Issues}
\begin{itemize}
    \item Should components know their parent? Depends (e.g., for traversal).
    \item Where to put add/remove/get\_child? In Component (uniform interface) or only in Composite (more type safety).
    \item Is child ordering important? What data structure to use for children?
\end{itemize}

\subsection*{Composite Pattern: GUI Example}
\begin{itemize}
    \item \textbf{Bad design:} Each widget type has a different interface; Window must know how to update each.
    \item \textbf{Better:} All widgets implement a common interface. Window can call draw() on all.
    \item \textbf{Best:} Composite pattern; both simple widgets and containers implement the Widget interface; containers can contain children, and Window can treat everything uniformly.
\end{itemize}

\subsection*{Decorator Pattern}
\begin{itemize}
    \item \textbf{Intent:} Add responsibilities to objects dynamically; a flexible alternative to subclassing.
    \item \textbf{Structure:}
        \begin{verbatim}
Component
  +operation()
ConcreteComponent
  +operation()
Decorator
  +component: Component
  +operation()
ConcreteDecoratorA/B
  +added_state/behaviour
  +operation()
        \end{verbatim}
    \item \textbf{Example:} FileReader can be decorated with BufferedFileReader for buffering.
    \item \textbf{Benefits:} Add features at runtime, combine features flexibly.
    \item \textbf{Liabilities:} Many small classes; can look like Adapter.
\end{itemize}

\subsection*{Observer Pattern}
\begin{itemize}
    \item \textbf{Intent:} One-to-many dependency; when subject changes, observers are notified.
    \item \textbf{Also Known As:} Publish-Subscribe, Dependents, Model-View.
    \item \textbf{Structure:}
        \begin{verbatim}
Subject
  +attach(), +detach(), +notify()
Observer
  +update()
ConcreteSubject, ConcreteObserver
        \end{verbatim}
    \item \textbf{Benefits:} Decouples subject from observer; supports event broadcasting; dynamic addition/removal.
    \item \textbf{Liabilities:} Cascading notifications; observers may need to deduce what changed.
\end{itemize}

\subsection*{Observer Pattern: Implementation Issues}
\begin{itemize}
    \item How does the subject track observers? (Array, set, etc.)
    \item Observers may subscribe to specific events (publish-subscribe).
    \item Observers can be subjects themselves (chained notifications).
    \item Subject can use push (send data) or pull (just notify, observer pulls info).
\end{itemize}

\subsection*{Other Patterns and Pitfalls}
\begin{itemize}
    \item Iterator, Strategy, Visitor, MVC/MVVM.
    \item \textbf{Pattern-abuse:} Don't use patterns everywhere just because they're cool; over-abstraction leads to complexity, cognitive overload, and performance costs.
    \item \textbf{Anti-patterns/code smells:} Deep class hierarchies, unnecessary abstractions, 1:1 class-to-noun mapping, etc.
\end{itemize}

\subsection*{Over-engineered Design Example}
\begin{itemize}
    \item Example: Pokemon system using Singleton, Composite, Decorator, Factory, etc. All patterns at once make the code hard to understand, maintain, and extend.
    \item \textbf{Simpler alternative:} Use basic classes with only the needed features.
    \item \textbf{Lesson:} Only use patterns as needed; defer adding abstractions unless justified.
\end{itemize}

\subsection*{Summary}
\begin{itemize}
    \item Deferred implementation (via polymorphism) achieves low coupling.
    \item Composition enables safe multiple inheritance.
    \item Apply patterns judiciously, not for their own sake.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 14: Software Testing Terminologies and Strategies (\texttt{ch14.pdf})}

\subsection*{Attitudes toward testing}
\begin{itemize}
    \item Humorous myths: “Real programmers need no testing!” “Testing is for the weak.” “Most functions rely on built-in types, so no need to test.”
    \item \textbf{Message:} These are dangerous attitudes; thorough testing is an essential part of quality software.
\end{itemize}

\subsection*{Three hard problems in Computer Science}
\begin{itemize}
    \item \textbf{Phil Karlton’s quote:} “There are only two hard things in Computer Science: cache invalidation and naming things.” Off-by-one errors are added as a third by the slides.
\end{itemize}

\subsection*{Building Quality Software}
\begin{itemize}
    \item \textbf{External qualities:} Correctness, reliability, efficiency, integrity.
    \item \textbf{Internal qualities:} Portability, maintainability, flexibility.
    \item \textbf{Quality Assurance:} The process (including testing) to uncover and fix problems.
\end{itemize}

\subsection*{Testing: Limitations and Value}
\begin{itemize}
    \item \textbf{Testing can find bugs, but cannot guarantee bug-free software} (Halting Problem analogy).
    \item \textbf{Full testing is unachievable} for complex systems; some bugs will always slip through.
    \item Testing increases confidence and quality, but is inherently incomplete.
\end{itemize}

\subsection*{Validation vs. Verification}
\begin{itemize}
    \item \textbf{Validation (“Are we building the right product?”):} Does the software meet user needs?
    \item \textbf{Verification (“Are we building the product right?”):} Is each function correct and defect-free?
    \item \textbf{Acceptance tests:} Focus on validation; most other testing is verification.
\end{itemize}

\subsection*{Phases of Testing}
\begin{itemize}
    \item \textbf{Unit Testing:} Does each function/module do what it’s supposed to?
    \item \textbf{Integration Testing:} Do modules work together correctly?
    \item \textbf{Validation Testing:} Does the software meet requirements?
    \item \textbf{System Testing:} Does the software work in the overall system?
    \item \textbf{Complexity:} Lower for unit, higher for system testing.
    \item \textbf{Participants:} Developers do unit/integration; customers are involved in validation/system testing.
\end{itemize}

\subsection*{What’s so hard about testing?}
\begin{itemize}
    \item \textbf{Example: Boolean circuit with a stuck-at-0 fault.} Testing all inputs is impractical; need to find minimal “test vectors” that activate and propagate the bug.
    \item \textbf{Exhaustive testing is impractical.} Must select a small but effective test suite using heuristics.
\end{itemize}

\subsection*{Test Planning}
\begin{itemize}
    \item Specify strategy (which tests, coverage, outcome percentage), schedule, and resource estimates.
\end{itemize}

\subsection*{Input Space Partitioning}
\begin{itemize}
    \item \textbf{Ideal:} Partition inputs into sets with same behavior; test one value from each.
    \item \textbf{Reality:} Use heuristics to approximate these sets.
    \item \textbf{Execution equivalence:} Inputs leading to same code path are equivalent (e.g., all $x < 0$ for \texttt{abs(x)}).
    \item \textbf{Heuristics:} For a range, test at/around boundaries; for a set, test valid/invalid; for a value, test $x-1, x, x+1$.
    \item \textbf{Revealing subdomains:} Partition inputs into sets that will reveal an error if present.
\end{itemize}

\subsection*{Test Case: Four parts}
\begin{itemize}
    \item What to test, under what conditions, with what input, and what is the expected result.
    \item Steps: select input/config, specify expected, execute and document, compare to expected.
\end{itemize}

\subsection*{Types of test case designs}
\begin{itemize}
    \item \textbf{Black Box:} Functionality from outside; no code knowledge.
    \item \textbf{White Box:} Internals, control/data flow; code is required.
    \item \textbf{Regression:} Re-test to ensure no new defects after changes.
\end{itemize}

\subsection*{Black Box Testing}
\begin{itemize}
    \item \textbf{Heuristic:} Explore alternative paths through specification.
    \item \textbf{Boundary cases:} Test overflow, duplicates, nulls, aliasing, etc.
    \item \textbf{Advantages:} Not influenced by code, allows independent testers, can be written before code, robust to implementation change.
    \item \textbf{Limitations:} Cannot reveal certain bugs (e.g., logic bug at $x = -2$ in a broken \texttt{abs(x)}).
\end{itemize}

\subsection*{White Box Testing}
\begin{itemize}
    \item \textbf{Goal:} Execute all code components; measure coverage.
    \item \textbf{Coverage:} Statement, branch, path.
    \item \textbf{Heuristics:} Test all paths, all logical conditions, loops at boundaries, data flows.
    \item \textbf{Examples:} Condition testing (regex for email), loop testing (sum over list), data flow testing (average calculation, bank account).
    \item \textbf{Tools:} Automated coverage tools are vital.
\end{itemize}

\subsection*{Regression Testing}
\begin{itemize}
    \item \textbf{Purpose:} Prevent recurrence of fixed bugs.
    \item \textbf{Process:} Reproduce bug, document inputs/outputs, add to test suite, confirm fix.
    \item \textbf{Remember:} If a bug happened once, it can happen again.
\end{itemize}

\subsection*{Test case types in different phases}
\begin{itemize}
    \item Unit/Integration: black box, white box.
    \item Validation/System: black box.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 15: Software Testing, and with Python (\texttt{ch15.pdf})}

\subsection*{Testing in Python}
\begin{itemize}
    \item \textbf{Definition:} Evaluate system/components to verify requirements are met.
    \item \textbf{Tools:} Python has several, e.g., \texttt{pytest}.
\end{itemize}

\subsection*{pytest and its plugins}
\begin{itemize}
    \item \textbf{pytest:} User-friendly, powerful testing framework.
    \item \textbf{Installation:} \verb|pip install pytest|
    \item \textbf{Plugins:} \texttt{pytest-cov} (coverage), \texttt{pytest-xdist} (parallel), \texttt{pytest-mock}, \texttt{pytest-benchmark}.
\end{itemize}

\subsection*{pytest: Example}
\begin{verbatim}
class SimpleNeuralNetwork:
    def __init__(self):
        self.weights = [0.5, -0.51]
    def predict(self, inputs):
        return sum(w * i for w, i in zip(self.weights, inputs))
    def train(self, inputs, target):
        prediction = self.predict(inputs)
        error = target - prediction
        self.weights = [w + 0.1 * error * i for w, i in zip(self.weights, inputs)]
\end{verbatim}
\begin{itemize}
    \item \textbf{Test file:} Test functions start with \texttt{test\_} and assert expected behavior.
    \item \textbf{Assertions:} Used to check conditions; a failed assertion fails the test.
    \item \textbf{Running tests:} \texttt{pytest} in directory, with options (\texttt{-v}, \texttt{--maxfail=1}, specific files, etc.).
    \item \textbf{Test discovery:} Files and functions starting with \texttt{test\_} are discovered automatically.
\end{itemize}

\subsection*{Fixtures}
\begin{itemize}
    \item \textbf{Definition:} Fixed state/environment for tests.
    \item \textbf{Purpose:} Consistency, isolation, reusability, efficiency.
    \item \textbf{Types:} Setup/teardown, function/class/module/session scope.
    \item \textbf{Usage:} Define with \texttt{@pytest.fixture}; inject in test by argument.
    \item \textbf{Best practices:} Keep simple, scope properly, document, avoid interdependencies.
\end{itemize}

\subsection*{Parameterization}
\begin{itemize}
    \item \textbf{Definition:} Run the same test with different input data.
    \item \textbf{Benefits:} More coverage, less duplication, maintainability, efficiency.
    \item \textbf{Usage:} \texttt{@pytest.mark.parametrize} decorator.
    \item \textbf{Example:} Test a function for multiple input/output pairs.
\end{itemize}

\subsection*{Mocks and Stubs}
\begin{itemize}
    \item \textbf{Mocking:} Simulate object behavior to isolate tests.
    \item \textbf{Benefits:} Isolation, control, speed, reliability, state collection.
    \item \textbf{pytest-mock:} Plugin for mocking; use \texttt{mocker.Mock()}.
    \item \textbf{Stubs:} Simplified module used to simulate lower-level modules in top-down testing.
\end{itemize}

\subsection*{Testing Strategies with Mocks and Stubs}
\begin{itemize}
    \item \textbf{Top-Down:} Test high-level first, use stubs for lower modules.
    \item \textbf{Bottom-Up:} Test low-level modules first, use drivers for higher levels.
    \item \textbf{Sandwich (Hybrid):} Combine both; practical for real projects.
    \item \textbf{Each has advantages/disadvantages} (e.g., stub/driver complexity, timing of bug detection).
\end{itemize}

\subsection*{Performance Testing and Benchmarking}
\begin{itemize}
    \item \textbf{Benchmarking:} Measure performance under specific conditions; micro/macro/synthetic/real-world.
    \item \textbf{pytest-benchmark:} Plugin to benchmark code; use \texttt{benchmark()} in test.
    \item \textbf{Best practices:} Isolate benchmarks, use realistic workloads, repeat for accuracy, document results.
\end{itemize}

\subsection*{Profiling}
\begin{itemize}
    \item \textbf{Definition:} Analyze program to find performance bottlenecks.
    \item \textbf{Key:} More detailed than benchmarking; focus on functions, calls, and resource usage.
    \item \textbf{Tools:} \texttt{cProfile}, \texttt{profile}, \texttt{line\_profiler}.
    \item \textbf{Difference from benchmarking:} Benchmarking measures overall performance; profiling breaks down by code unit.
    \item \textbf{Visualization:} Use KCachegrind (with \texttt{pyprof2calltree}) to analyze call graphs.
\end{itemize}

\subsection*{Code Coverage}
\begin{itemize}
    \item \textbf{Definition:} Fraction of code executed by tests.
    \item \textbf{pytest-cov:} Plugin for coverage; generates terminal and HTML reports.
    \item \textbf{Best practices:} Aim for high coverage, but focus on meaningful tests, not just numbers.
\end{itemize}

\subsection*{Suggested Testing Practices}
\begin{itemize}
    \item \textbf{Directory structure:} \texttt{src/} for source, \texttt{tests/} for tests.
    \item \textbf{Naming:} Consistent \texttt{test\_*.py} naming.
    \item \textbf{Use fixtures for common setup.}
    \item \textbf{Keep tests independent.}
    \item \textbf{Document tests with docstrings and README.}
    \item \textbf{Code duplication:} Occasionally okay for clarity or legacy, but prefer to avoid by using fixtures/helpers.
\end{itemize}

\subsection*{Reminder}
\begin{itemize}
    \item Testing is essential—tools may change, but the principles apply across languages and environments.
    \item Regular testing and optimization ensure reliable, maintainable, high-quality software.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chapter 16: Profiling, and code optimisation (\texttt{ch16.pdf})}

\subsection*{More on Profiling}
\begin{itemize}
    \item \textbf{Profiling:} Analyzing and measuring program performance to see where time is spent.
    \item \textbf{Why:} Useful for long-running or complex code; helps pinpoint bottlenecks.
    \item \textbf{Benefits:} Quick process; can reveal peace of mind or identify slow areas. Identifying bottlenecks allows precise, effective optimization—sometimes yielding 100x–1000x speedups!
    \item \textbf{Energy:} Profiling also helps ensure efficient use of system resources (important for High Performance Computing).
\end{itemize}

\subsection*{When to Profile}
\begin{itemize}
    \item \textbf{Relevant when:} Code is working and approaching deployment; anything running for more than a few minutes.
    \item \textbf{Profiling is cheap:} If no major bottlenecks, you quickly know code is OK; if there’s a bottleneck, targeted optimization can yield massive improvements.
\end{itemize}

\subsection*{Types of Profiler}
\begin{itemize}
    \item \textbf{Manual:} Use \texttt{print()} and timing (e.g., \texttt{time.monotonic()}) to measure code sections.
    \item \textbf{Function-level:} Counts calls and execution time per function, including/excluding child functions (e.g., \texttt{cProfile}).
    \item \textbf{Line-level:} Measures time for individual code lines (good for complex or long functions).
\end{itemize}

\subsection*{Selecting Appropriate Test Case}
\begin{itemize}
    \item Profilers add overhead (code runs slower).
    \item High-resolution profiling uses more CPU/memory/storage.
    \item Choose a test case representative of workload, but small enough to run quickly (ideally a few minutes).
    \item Example: Simulate one day of a year-long simulation to profile, not the whole year.
\end{itemize}

\subsection*{Function-level Profiling - Example}
\begin{verbatim}
def a_1():
    for i in range(3): b_1()
    time.sleep(1)
    b_2()
def b_1(): c_1(); c_2()
def b_2(): time.sleep(1)
def c_1(): time.sleep(0.5)
def c_2(): time.sleep(0.3); d_1()
def d_1(): time.sleep(0.1)
a_1()
\end{verbatim}
\begin{itemize}
    \item Run with \texttt{python -m cProfile -o out.prof ...}; view output with \texttt{snakeviz} or \texttt{kcachegrind}.
\end{itemize}

\subsection*{Optimisation}
\begin{itemize}
    \item \textbf{Profiling:} Understands program behavior.
    \item \textbf{Optimization:} Changes code or config based on profiling.
    \item \textbf{Major methods:}
        \begin{itemize}
            \item \textbf{Algorithm:} Analyze/replace with better ones (hash tables vs lists, parallelism, heuristics, randomized algorithms).
            \item \textbf{Bottleneck identification:} Use profiling tools to find “hotspots.”
            \item \textbf{Code and memory:} Inlining, loop unrolling, cache awareness, recursion best practices, GC tuning, efficient memory allocation.
            \item \textbf{I/O:} Buffering, async I/O.
            \item \textbf{Concurrency:} Thread pools, lock-free data structures.
            \item \textbf{Caching:} Data/result caching.
        \end{itemize}
    \item \textbf{Rules:}
        \begin{enumerate}
            \item Don’t optimize when unnecessary.
            \item Don’t optimize before the code is correct.
            \item Don’t optimize without regression tests.
            \item Know when to stop.
        \end{enumerate}
\end{itemize}

\subsection*{Performance vs. Maintainability}
\begin{itemize}
    \item \textbf{Knuth’s quote:} “Premature optimization is the root of all evil.”
    \item Maintainability is as important as performance; optimize only the critical 3\% of code.
    \item Don’t micro-optimize everything; focus on algorithms/data structures and profile-driven changes.
\end{itemize}

\subsection*{Understanding Computer Program Execution and Optimisation}
\begin{itemize}
    \item \textbf{How programs run:} Load from storage, fetch/decode/execute/store instructions.
    \item \textbf{Function call and stack:} Each call creates a stack frame with parameters, locals, return address; stack grows/shrinks per call.
    \item \textbf{Example in C:} Shows stack frames for main(), bar(), foo().
\end{itemize}

\subsection*{Memory System}
\begin{itemize}
    \item \textbf{Hierarchy:} L1/L2/L3 cache (fast, small), RAM, disk (slow, large).
    \item \textbf{Cache:} Data moves from main memory to caches based on temporal/spatial locality, cache misses, replacement policy, prefetching.
    \item \textbf{Example:}
        \begin{itemize}
            \item \texttt{sequential\_access()} faster than \texttt{random\_access()} due to better cache locality.
        \end{itemize}
\end{itemize}

\subsection*{Code Optimisation Techniques}
\begin{itemize}
    \item \textbf{Inlining:} Replace function calls with body to avoid call overhead (may hurt readability/code size).
    \item \textbf{Loop unrolling:} Replicate loop body to reduce control overhead and allow instruction-level parallelism.
    \item \textbf{Struct field alignment:} Arrange struct fields to minimize padding and cache misses (e.g., C structs).
    \item \textbf{Tail recursion:} Special case of recursion where last operation is recursive call; allows stack frame reuse (Python does not optimize this by default).
    \item \textbf{GC tuning:} Adjust thresholds to balance memory use and pause times; understand reference counting and cycles.
    \item \textbf{Memory pools:} Allocate/deallocate memory in bulk to reduce fragmentation and allocation overhead (hard in Python, easier in C).
    \item \textbf{Object pools:} Reuse objects rather than create/destroy repeatedly (can be implemented in Python via queues).
    \item \textbf{Language-specific:} Use built-in functions (e.g., Python’s \texttt{sum}, \texttt{in}), list comprehensions, etc., for speed and readability.
\end{itemize}

\subsection*{Benchmarking/Profiling and Results}
\begin{itemize}
    \item Use benchmarking and profiling to prove optimizations are effective.
    \item Don’t optimize before software is proven correct.
    \item Abstractions hide both complexity and performance implications.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Toolchains (Python) And Consistent Development Environment (\texttt{ch\_toolchains.pdf})}

\subsection*{Toolchain: Overview}
\begin{itemize}
    \item \textbf{Toolchain:} Series of development tools from code writing to deployment.
    \item \textbf{Key question:} For each new project/language/framework: Is there a tool for each important task?
\end{itemize}

\subsection*{Source control}
\begin{itemize}
    \item \textbf{Git:} The de facto standard; platforms like GitHub/GitLab/Bitbucket.
    \item \textbf{Purpose:} Collaboration, history, rollback.
\end{itemize}

\subsection*{Development Environment - Interpreter}
\begin{itemize}
    \item \textbf{Python interpreter:} CPython, PyPy (faster), Jython (Java integration).
    \item \textbf{Choose version:} E.g., Python 3.11/3.12 for compatibility.
\end{itemize}

\subsection*{Development Environment - Virtual Environments}
\begin{itemize}
    \item \textbf{Problem:} “Python version hell”—project dependencies can conflict.
    \item \textbf{virtualenv/venv:} Create isolated environments per project (\texttt{python -m venv myenv}).
\end{itemize}

\subsection*{Development Environment - Package Manager}
\begin{itemize}
    \item \textbf{pip:} Installs/updates Python libraries from PyPI.
    \item \textbf{Poetry:} Modern, manages dependencies and builds.
    \item \textbf{requirements.txt:} Lists package/version; ensures reproducibility.
\end{itemize}

\subsection*{Build and Dependency Management}
\begin{itemize}
    \item \textbf{setuptools:} For packaging/distribution (setup.py).
    \item \textbf{Poetry:} Also handles builds (\texttt{pyproject.toml}).
    \item \textbf{Wheel:} Binary distribution format.
\end{itemize}

\subsection*{Consistent and Easy-to-setup Environments}
\begin{itemize}
    \item \textbf{Docker:} Bundles app with dependencies (solves ``Python version hell'').
    \item \textbf{VMs:} Emulates OS/hardware (heavyweight).
    \item \textbf{Nix/devenv:} Reproducible environments; all versions, all packages, fully specified.
\end{itemize}

\subsection*{IDE/Text Editor}
\begin{itemize}
    \item \textbf{PyCharm:} Full-featured (not free).
    \item \textbf{VSCode:} Lightweight, extensible.
    \item \textbf{Jupyter:} For interactive data science.
    \item \textbf{Vim, Emacs, Helix, etc.:} Powerful with language server support.
\end{itemize}

\subsection*{Linters and Formatters}
\begin{itemize}
    \item \textbf{Flake8:} Style and syntax errors.
    \item \textbf{Black:} Automatic code formatting.
    \item \textbf{Pylint:} Code analysis, style, errors.
\end{itemize}

\subsection*{Static Code Analysis}
\begin{itemize}
    \item \textbf{Bandit:} Checks security issues.
    \item \textbf{SonarQube:} Advanced metrics (free community edition available).
    \item \textbf{Pylint:} Also does static analysis.
\end{itemize}

\subsection*{Testing Frameworks}
\begin{itemize}
    \item \textbf{unittest:} Built-in.
    \item \textbf{pytest:} Popular, feature-rich.
    \item \textbf{pytest-cov:} Coverage plugin.
    \item \textbf{pytest-benchmark:} Performance benchmarking.
    \item \textbf{doctest:} Tests in docstrings.
    \item \textbf{Fuzzers:} E.g., Google Atheris for random input testing.
\end{itemize}

\subsection*{CI/CD (Continuous Integration/Deployment)}
\begin{itemize}
    \item \textbf{GitHub Actions, GitLab Pipeline, Jenkins:} Automate testing, building, deployment.
    \item \textbf{Tox:} Tests across multiple Python versions.
\end{itemize}

\subsection*{Debugging}
\begin{itemize}
    \item \texttt{print():} Simple but manual and error-prone.
    \item \texttt{pdb:} Built-in debugger.
    \item IDE debuggers: Breakpoints, variable inspection.
\end{itemize}

\subsection*{Profiling}
\begin{itemize}
    \item \texttt{cProfile:} CPU/time profiling.
    \item \texttt{profile:} Pure Python, slower.
\end{itemize}

\subsection*{Documentation}
\begin{itemize}
    \item \texttt{docstring:} In-code docs.
    \item \texttt{Sphinx:} Generates professional docs from docstrings.
\end{itemize}

\subsection*{Deployment}
\begin{itemize}
    \item \texttt{Docker, VM:} Bundle and deploy with dependencies.
    \item \texttt{Nuitka:} Compile Python to binary.
\end{itemize}

\subsection*{Using Nix and devenv: Example}
\begin{itemize}
    \item \textbf{Install Nix \& devenv:} See provided commands.
    \item \textbf{devenv.nix:} Specifies Python packages, linters, tasks, git hooks.
    \item \textbf{poetry:} Used for package/dependency management within the environment.
    \item \textbf{Reproducibility:} Any developer can use the same files to get an identical environment.
\end{itemize}

\end{document}